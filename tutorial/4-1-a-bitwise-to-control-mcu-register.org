* Bitwise operations to control =RP2040= register

** 1. Where to get the =register= address

The first thing before reading data from or writing data to the =RP2040= register, you need to know where to find those register addresses, as those addresses actually just are pointers to the location of the register memory.

Here is the chapter structure convention of the =RP2040 Datasheet=:

- Overview
- ...
- List of Registers

For example, the chapter =2.14. Subsystem Resets=:

#+BEGIN_SRC text
  2.14. Subsystem Resets
  2.14.1. Overview
  2.14.2. Programmer’s Model
  2.14.3. List of Registers
#+END_SRC

That =List of Registers= sub-chapter is the right place where you can get the given functional register address.

Take an example of the =2.14.3. List of Registers=, it said:

The reset controller registers start at a base address of ~0x4000c000~ (defined as RESETS_BASE in SDK).

| Offset | Name       | Info             |
|--------+------------+------------------|
|    ~0x0~ | RESET      | Reset control.   |
|    ~0x4~ | WDSEL      | Watchdog select. |
|    ~0x8~ | RESET_DONE | Reset done.      |


That means if you want to send bytes to the =RESET (Rest control) Register=, you need the following address value:

#+BEGIN_SRC c
  //
  // Page 177 -> 2.14.3
  //
  // Reset Registers
  //
  #define RESET_BASE_ADDR			0x4000c000
  #define RESET_CONTROL_ADDR		(RESET_BASE_ADDR + 0x00)
  #define RESET_WATCH_DOG_SELCECT_ADDR	(RESET_BASE_ADDR + 0x04)
  #define RESET_DONE_ADDR			(RESET_BASE_ADDR + 0x08)

  // 0x4000c000 + x000
  reg_u32 *reset_control_reg = (reg_u32*)RESET_CONTROL_ADDR;

  // 0x4000c000 + 0x04
  reg_u32 *reset_watch_dog_select_reg = (reg_u32*)RESET_WATCH_DOG_SELCECT_ADDR;

  // 0x4000c000 + 0x08
  reg_u32 *reset_done_reg = (reg_u32*)RESET_DONE_ADDR;
#+END_SRC
   

** 2. How to read data from or write data to =register=

*** Bitwise operations

You need to know the basic bitwise operations, as that's the fundamental way to read data from or write data to the RP2040 register.

+ Use ~value |= (1<< x)~ to set bit x to ~1~ (AKA: set a bit)
+ Use ~value &= ~(1<< x)~ to set bit x to ~0~ (AKA: clear a bit)
+ Use ~value ^= (1<< x)~ to toggle bit x   (AKA: toggle a bit)

For example:



#+BEGIN_SRC c
  //
  // Page 178:
  //
  // Reset control register: Set the bit5 to `0` to enable GPIO (iobank0) functionality
  //
  reg_u32 *reset_control_reg = (reg_u32*)RESET_CONTROL_ADDR;
  *reset_control_reg &= ~(1 << 5);

	//
	// Page 46 -> 2.3.17, SIO: GPIO_OE Register
	//
	// SIO GPIO out enable register: Set the bit{LED_PIN} to 1 to enable GPIO_{LED_PIN} output mode
	//
	reg_u32 *gpio_out_enable_reg = (reg_u32*)SIO_GPIO_OUT_ENABLE_ADDR;
	*gpio_out_enable_reg |= (1 << LED_PIN);
#+END_SRC


*** =SIO= and =Atomic Register Access=

**** =SIO=

=SIO= (Single-Cycle IO block) provides high-speed, deterministic access to GPIOs via each processor’s IOPORT. The =SIO= appears as memory-mapped hardware within the IOPORT space.

If you don't use =SIO= to access GPIO peripheral, =Cortex-M0+= requires =two cycles= for a load or store, and may have to wait longer due to contention from other system bus masters. But with =SIO=, All GPIO peripheral reads and writes (and therefore all SIO accesses) take place in exactly =one cycle=!!!

That's why you should read from or write to =SIO= registers to deal with GPIO peripherals.

=SIO= registers are mapped to word-aligned addresses in the range =0xd0000000…0xd000017c=.


**** =Atomic Register Access=


